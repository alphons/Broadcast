<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Live Stream</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }

    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #0f0f0f;
      color: #e0e0e0;
      min-height: 100vh;
    }

    h1 { color: #fff; margin-bottom: 1.5rem; font-size: 1.6rem; }
    h2 { color: #ccc; margin: 0 0 1rem; font-size: 1.2rem; }

    #mode-select {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 2rem;
    }

    .mode-btn {
      padding: 0.6rem 1.4rem;
      border: 2px solid #444;
      background: #1a1a1a;
      color: #ccc;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: border-color 0.2s, color 0.2s;
    }
    .mode-btn:hover { border-color: #888; color: #fff; }
    .mode-btn.active { border-color: #4a9eff; color: #4a9eff; }

    .section {
      display: none;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 1.5rem;
      max-width: 760px;
    }
    .section.active { display: block; }

    video {
      width: 100%;
      max-width: 720px;
      height: 405px;
      background: #000;
      display: block;
      border-radius: 6px;
      margin-bottom: 1rem;
      border: 1px solid #333;
    }

    .controls { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem; }

    button {
      padding: 0.5rem 1.1rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      transition: opacity 0.2s;
    }
    button:disabled { opacity: 0.4; cursor: not-allowed; }

    .btn-primary { background: #4a9eff; color: #fff; }
    .btn-danger  { background: #e05252; color: #fff; }
    .btn-neutral { background: #444; color: #ddd; }

    .status {
      font-size: 0.85rem;
      color: #888;
      padding: 0.4rem 0;
      min-height: 1.4em;
    }
    .status.ok  { color: #5cb85c; }
    .status.err { color: #e05252; }
    .status.info{ color: #4a9eff; }

    .stat-bar {
      margin-top: 1rem;
      font-size: 0.8rem;
      color: #666;
      border-top: 1px solid #2a2a2a;
      padding-top: 0.75rem;
    }
    .stat-bar span { margin-right: 1.5rem; }
  </style>
</head>
<body>

<h1>Live Stream</h1>

<div id="mode-select">
  <button class="mode-btn" onclick="showSection('broadcaster')">Uitzenden</button>
  <button class="mode-btn" onclick="showSection('viewer')">Kijken</button>
</div>

<!-- ===== BROADCASTER ===== -->
<div id="broadcaster" class="section">
  <h2>Uitzenden</h2>
  <video id="broadcaster-preview" autoplay muted playsinline></video>
  <div class="controls">
    <button id="b-start" class="btn-primary" onclick="startBroadcast()">Start Uitzending</button>
    <button id="b-stop"  class="btn-danger"  onclick="stopBroadcast()"  disabled>Stop Uitzending</button>
  </div>
  <div id="b-status" class="status">Niet actief</div>
  <div class="stat-bar">
    <span>Chunks verzonden: <b id="b-chunks">0</b></span>
    <span>Kijkers: <b id="b-viewers">0</b></span>
  </div>
</div>

<!-- ===== VIEWER ===== -->
<div id="viewer" class="section">
  <h2>Kijken</h2>
  <video id="viewer-video" autoplay playsinline controls></video>
  <div class="controls">
    <button id="v-start" class="btn-primary" onclick="startWatching()">Verbinden</button>
    <button id="v-stop"  class="btn-danger"  onclick="stopWatching()"  disabled>Verbreken</button>
  </div>
  <div id="v-status" class="status">Niet verbonden</div>
  <div class="stat-bar">
    <span>Ontvangen chunks: <b id="v-chunks">0</b></span>
    <span>Buffer wachtrij: <b id="v-queue">0</b></span>
  </div>
</div>

<script>
// ===========================================================================
// UTILITY
// ===========================================================================
function showSection(name) {
  ['broadcaster', 'viewer'].forEach(id => {
    document.getElementById(id).classList.remove('active');
  });
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
  document.getElementById(name).classList.add('active');
  document.querySelector(`.mode-btn[onclick="showSection('${name}')"]`).classList.add('active');
}

function setStatus(elId, text, cls = '') {
  const el = document.getElementById(elId);
  el.className = 'status ' + cls;
  el.textContent = text;
}

// ===========================================================================
// BROADCASTER
// ===========================================================================
let mediaRecorder = null;
let broadcastStream = null;
let bChunkCount = 0;
let bViewerPoll = null;

function selectMimeType() {
  const candidates = [
    'video/webm;codecs=vp8,opus',
    'video/webm;codecs=vp9,opus',
    'video/webm;codecs=vp8',
    'video/webm'
  ];
  for (const t of candidates) {
    if (MediaRecorder.isTypeSupported(t)) return t;
  }
  return '';
}

async function startBroadcast() {
  try {
    // Reset server state for a fresh broadcast session
    await fetch('/api/stream/reset', { method: 'POST' });

    broadcastStream = await navigator.mediaDevices.getUserMedia({
      video: { width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30 } },
      audio: true
    });
  } catch (err) {
    setStatus('b-status', 'Fout: ' + err.message, 'err');
    return;
  }

  document.getElementById('broadcaster-preview').srcObject = broadcastStream;

  const mimeType = selectMimeType();
  if (!mimeType) {
    setStatus('b-status', 'Geen ondersteunde video codec gevonden.', 'err');
    return;
  }

  bChunkCount = 0;
  document.getElementById('b-chunks').textContent = '0';

  mediaRecorder = new MediaRecorder(broadcastStream, {
    mimeType,
    videoBitsPerSecond: 1_500_000,
    audioBitsPerSecond: 128_000
  });

  mediaRecorder.ondataavailable = async (event) => {
    if (!event.data || event.data.size === 0) return;

    bChunkCount++;
    document.getElementById('b-chunks').textContent = bChunkCount;

    try {
      const res = await fetch('/api/stream/broadcast', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/octet-stream',
          'X-Mime-Type': mimeType
        },
        body: event.data
      });
      if (res.ok) {
        const json = await res.json();
        document.getElementById('b-viewers').textContent = json.viewers ?? 0;
        setStatus('b-status', `Actief — codec: ${mimeType}`, 'ok');
      } else {
        setStatus('b-status', `Server fout: ${res.status}`, 'err');
      }
    } catch (err) {
      setStatus('b-status', 'Netwerkfout: ' + err.message, 'err');
    }
  };

  mediaRecorder.onerror = (err) => {
    setStatus('b-status', 'MediaRecorder fout: ' + err.error?.message, 'err');
  };

  // timeslice 250ms: first dataavailable = WebM EBML init, rest = media clusters
  mediaRecorder.start(250);

  document.getElementById('b-start').disabled = true;
  document.getElementById('b-stop').disabled = false;
  setStatus('b-status', 'Starten...', 'info');
}

function stopBroadcast() {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
  }
  mediaRecorder = null;

  if (broadcastStream) {
    broadcastStream.getTracks().forEach(t => t.stop());
    broadcastStream = null;
  }

  document.getElementById('broadcaster-preview').srcObject = null;
  document.getElementById('b-start').disabled = false;
  document.getElementById('b-stop').disabled = true;
  setStatus('b-status', 'Gestopt');
}

// ===========================================================================
// VIEWER
// ===========================================================================
let eventSource    = null;
let mediaSource    = null;
let sourceBuffer   = null;
let pendingChunks  = [];   // Chunks wachtend om appended te worden
let initDone       = false; // true zodra init-segment volledig door SourceBuffer verwerkt is
let isAppending    = false;
let vChunkCount    = 0;
let activeMime     = '';
let liveTimer      = null;  // interval voor live-sync

const MIME_CANDIDATES = [
  'video/webm;codecs=vp8,opus',
  'video/webm;codecs=vp9,opus',
  'video/webm;codecs=vp8',
  'video/webm'
];

// Max aantal chunks in de wachtrij. Als de queue groeit omdat de browser
// langzamer verwerkt dan chunks binnenkomen, drop dan de oudste media-chunks
// (maar nooit de init). Bij live-video is actualiteit belangrijker dan volledigheid.
const MAX_QUEUE = 20;

function base64ToUint8Array(b64) {
  const binary = atob(b64);
  const buf = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) buf[i] = binary.charCodeAt(i);
  return buf;
}

// Verwijder oude gebufferde data zodat de browser geen geheugenprobleem krijgt.
// Houd maximaal 20 seconden achter de huidige afspeelpositie.
function evictOldBuffer() {
  if (!sourceBuffer || sourceBuffer.updating) return;
  if (!mediaSource || mediaSource.readyState !== 'open') return;
  try {
    const video = document.getElementById('viewer-video');
    const ct = video.currentTime;
    if (ct > 20) {
      sourceBuffer.remove(0, ct - 20);
    }
  } catch (e) { /* ignore */ }
}

// Spring naar het einde van de buffer als we meer dan 1.5 seconde achter lopen.
// Zo blijft de kijker dicht op live, ook als de browser even heeft gebufferd.
function syncToLive() {
  if (!sourceBuffer || !mediaSource || mediaSource.readyState !== 'open') return;
  if (sourceBuffer.updating) return;
  const video = document.getElementById('viewer-video');
  if (video.readyState < 2) return;  // nog niets afgespeeld

  try {
    const buffered = sourceBuffer.buffered;
    if (buffered.length === 0) return;
    const liveEdge = buffered.end(buffered.length - 1);
    const behind = liveEdge - video.currentTime;
    if (behind > 1.5) {
      // Meer dan 1.5s achter — spring naar live edge min een kleine marge
      video.currentTime = liveEdge - 0.1;
    }
  } catch (e) { /* ignore */ }
}

function drainQueue() {
  if (isAppending) return;
  if (!sourceBuffer || sourceBuffer.updating) return;
  if (pendingChunks.length === 0) return;
  if (!mediaSource || mediaSource.readyState !== 'open') return;

  isAppending = true;
  const item = pendingChunks.shift();
  document.getElementById('v-queue').textContent = pendingChunks.length;

  // CRITICAL: listener registreren VÓÓR appendBuffer aanroepen.
  // In sommige browsers/situaties kan updateend synchroon vuren.
  function onUpdateEnd() {
    isAppending = false;

    // Als dit de init was, zet initDone op true zodat media-chunks
    // pas daarna in de queue komen. Zo kan de SourceBuffer nooit
    // media ontvangen terwijl de codec-initialisatie nog loopt.
    if (item.isInit) {
      initDone = true;
      setStatus('v-status', 'Init verwerkt, stream start...', 'info');
    }

    drainQueue();
  }
  sourceBuffer.addEventListener('updateend', onUpdateEnd, { once: true });

  try {
    sourceBuffer.appendBuffer(item.data);
  } catch (err) {
    sourceBuffer.removeEventListener('updateend', onUpdateEnd);
    console.error('appendBuffer error:', err.name, err.message);
    isAppending = false;
    if (err.name === 'QuotaExceededError') {
      evictOldBuffer();
      // Zet het item terug en probeer opnieuw na de evict
      pendingChunks.unshift(item);
      setTimeout(drainQueue, 50);
    }
  }
}

function queueChunk(data, isInit = false) {
  if (isInit) {
    // Init vervangt alles: leeg de queue en begin opnieuw
    pendingChunks = [{ data, isInit: true }];
    initDone = false;
    isAppending = false;
    drainQueue();
    return;
  }

  // Media-chunk: alleen toevoegen als init al verwerkt is
  if (!initDone) return;

  pendingChunks.push({ data, isInit: false });

  // Begrens de queue: als hij te lang wordt, gooi dan de oudste
  // media-chunks weg (niet de init). Zo blijven we dicht op live.
  while (pendingChunks.length > MAX_QUEUE) {
    pendingChunks.shift();
  }

  document.getElementById('v-queue').textContent = pendingChunks.length;
  drainQueue();
}

async function openSourceBuffer() {
  let serverMime = '';
  try {
    const res = await fetch('/api/stream/info');
    if (res.ok) {
      const info = await res.json();
      serverMime = info.mimeType || '';
    }
  } catch (e) { /* val terug op kandidatenlijst */ }

  const candidates = serverMime
    ? [serverMime, ...MIME_CANDIDATES.filter(m => m !== serverMime)]
    : MIME_CANDIDATES;

  for (const mime of candidates) {
    if (!MediaSource.isTypeSupported(mime)) continue;
    try {
      sourceBuffer = mediaSource.addSourceBuffer(mime);
      sourceBuffer.mode = 'sequence';
      activeMime = mime;
      setStatus('v-status', `Verbonden (${mime}). Wachten op stream...`, 'info');
      connectEventSource();

      // Elke seconde live-sync controleren
      liveTimer = setInterval(syncToLive, 1000);
      return;
    } catch (e) { /* probeer volgende */ }
  }
  setStatus('v-status', 'Geen ondersteunde MSE codec beschikbaar.', 'err');
}

function startWatching() {
  // State resetten
  pendingChunks = [];
  initDone      = false;
  isAppending   = false;
  vChunkCount   = 0;
  activeMime    = '';
  document.getElementById('v-chunks').textContent = '0';
  document.getElementById('v-queue').textContent  = '0';

  const video = document.getElementById('viewer-video');
  mediaSource = new MediaSource();
  video.src = URL.createObjectURL(mediaSource);

  mediaSource.addEventListener('sourceopen', openSourceBuffer);
  mediaSource.addEventListener('sourceended', () =>
    setStatus('v-status', 'Stream beëindigd.', 'info'));
  mediaSource.addEventListener('sourceclose', () =>
    setStatus('v-status', 'MediaSource gesloten.', 'info'));

  document.getElementById('v-start').disabled = true;
  document.getElementById('v-stop').disabled  = false;
  setStatus('v-status', 'Verbinden...', 'info');
}

function connectEventSource() {
  eventSource = new EventSource('/api/stream/watch');

  eventSource.onopen = () =>
    setStatus('v-status', 'Verbonden. Wachten op init-segment...', 'info');

  // Init-event: WebM EBML-header — moet EERST in de SourceBuffer
  eventSource.addEventListener('init', (event) => {
    vChunkCount = 0;
    document.getElementById('v-chunks').textContent = '0';
    setStatus('v-status', 'Init ontvangen, verwerken...', 'info');
    queueChunk(base64ToUint8Array(event.data), true);
  });

  // Chunk-event: gewone WebM media-cluster
  eventSource.addEventListener('chunk', (event) => {
    const bytes = base64ToUint8Array(event.data);
    queueChunk(bytes, false);
    vChunkCount++;
    document.getElementById('v-chunks').textContent = vChunkCount;

    // Autoplay als video gepauzeerd is maar er wel data is
    const video = document.getElementById('viewer-video');
    if (video.paused && video.readyState >= 3) video.play().catch(() => {});

    if (vChunkCount === 1) setStatus('v-status', 'Stream actief.', 'ok');
  });

  eventSource.onerror = () => {
    setStatus('v-status', 'Verbinding onderbroken, herverbinden...', 'err');
    // Bij herverbinding stuurt de server opnieuw het init-segment;
    // reset zodat queueChunk dat correct als init behandelt.
    initDone      = false;
    pendingChunks = [];
    isAppending   = false;
  };
}

function stopWatching() {
  if (liveTimer) { clearInterval(liveTimer); liveTimer = null; }

  if (eventSource) { eventSource.close(); eventSource = null; }

  pendingChunks = [];
  initDone      = false;
  isAppending   = false;

  function teardown() {
    try {
      if (mediaSource && mediaSource.readyState === 'open') mediaSource.endOfStream();
    } catch (e) { /* ignore */ }
    mediaSource  = null;
    sourceBuffer = null;
    const video = document.getElementById('viewer-video');
    video.removeAttribute('src');
    video.load();
  }

  // endOfStream mag niet worden aangeroepen terwijl updating=true
  if (sourceBuffer && sourceBuffer.updating) {
    sourceBuffer.addEventListener('updateend', teardown, { once: true });
  } else {
    teardown();
  }

  document.getElementById('v-start').disabled = false;
  document.getElementById('v-stop').disabled  = true;
  setStatus('v-status', 'Verbroken.');
}
</script>
</body>
</html>
