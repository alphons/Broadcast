<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Live Stream</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }

    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #0f0f0f;
      color: #e0e0e0;
      min-height: 100vh;
    }

    h1 { color: #fff; margin-bottom: 1.5rem; font-size: 1.6rem; }
    h2 { color: #ccc; margin: 0 0 1rem; font-size: 1.2rem; }

    #mode-select {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 2rem;
    }

    .mode-btn {
      padding: 0.6rem 1.4rem;
      border: 2px solid #444;
      background: #1a1a1a;
      color: #ccc;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: border-color 0.2s, color 0.2s;
    }
    .mode-btn:hover { border-color: #888; color: #fff; }
    .mode-btn.active { border-color: #4a9eff; color: #4a9eff; }

    .section {
      display: none;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 1.5rem;
      max-width: 760px;
    }
    .section.active { display: block; }

    video {
      width: 100%;
      max-width: 720px;
      height: 405px;
      background: #000;
      display: block;
      border-radius: 6px;
      margin-bottom: 1rem;
      border: 1px solid #333;
    }

    .controls { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem; }

    button {
      padding: 0.5rem 1.1rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      transition: opacity 0.2s;
    }
    button:disabled { opacity: 0.4; cursor: not-allowed; }

    .btn-primary { background: #4a9eff; color: #fff; }
    .btn-danger  { background: #e05252; color: #fff; }
    .btn-neutral { background: #444; color: #ddd; }

    .status {
      font-size: 0.85rem;
      color: #888;
      padding: 0.4rem 0;
      min-height: 1.4em;
    }
    .status.ok  { color: #5cb85c; }
    .status.err { color: #e05252; }
    .status.info{ color: #4a9eff; }

    .stat-bar {
      margin-top: 1rem;
      font-size: 0.8rem;
      color: #666;
      border-top: 1px solid #2a2a2a;
      padding-top: 0.75rem;
    }
    .stat-bar span { margin-right: 1.5rem; }
  </style>
</head>
<body>

<h1>Live Stream</h1>

<div id="mode-select">
  <button class="mode-btn" onclick="showSection('broadcaster')">Uitzenden</button>
  <button class="mode-btn" onclick="showSection('viewer')">Kijken</button>
</div>

<!-- ===== BROADCASTER ===== -->
<div id="broadcaster" class="section">
  <h2>Uitzenden</h2>
  <video id="broadcaster-preview" autoplay muted playsinline></video>
  <div class="controls">
    <button id="b-start" class="btn-primary" onclick="startBroadcast()">Start Uitzending</button>
    <button id="b-stop"  class="btn-danger"  onclick="stopBroadcast()"  disabled>Stop Uitzending</button>
  </div>
  <div id="b-status" class="status">Niet actief</div>
  <div class="stat-bar">
    <span>Chunks verzonden: <b id="b-chunks">0</b></span>
    <span>Kijkers: <b id="b-viewers">0</b></span>
  </div>
</div>

<!-- ===== VIEWER ===== -->
<div id="viewer" class="section">
  <h2>Kijken</h2>
  <video id="viewer-video" autoplay playsinline controls></video>
  <div class="controls">
    <button id="v-start" class="btn-primary" onclick="startWatching()">Verbinden</button>
    <button id="v-stop"  class="btn-danger"  onclick="stopWatching()"  disabled>Verbreken</button>
  </div>
  <div id="v-status" class="status">Niet verbonden</div>
  <div class="stat-bar">
    <span>Ontvangen chunks: <b id="v-chunks">0</b></span>
    <span>Buffer wachtrij: <b id="v-queue">0</b></span>
  </div>
</div>

<script>
// ===========================================================================
// UTILITY
// ===========================================================================
function showSection(name) {
  ['broadcaster', 'viewer'].forEach(id => {
    document.getElementById(id).classList.remove('active');
  });
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
  document.getElementById(name).classList.add('active');
  document.querySelector(`.mode-btn[onclick="showSection('${name}')"]`).classList.add('active');
}

function setStatus(elId, text, cls = '') {
  const el = document.getElementById(elId);
  el.className = 'status ' + cls;
  el.textContent = text;
}

// ===========================================================================
// WEBM KEYFRAME DETECTION
// Scans raw WebM bytes for a Cluster containing a SimpleBlock with the
// keyframe flag (bit 7) set. Used by the broadcaster to tag chunks so
// the server can track keyframe boundaries without parsing on its side.
// ===========================================================================
function webmHasKeyframe(buf) {
  // Find Cluster element ID: 0x1F 0x43 0xB6 0x75
  let pos = -1;
  for (let i = 0; i <= buf.length - 4; i++) {
    if (buf[i] === 0x1F && buf[i+1] === 0x43 && buf[i+2] === 0xB6 && buf[i+3] === 0x75) {
      pos = i + 4;
      break;
    }
  }
  if (pos < 0) return false;

  // Skip the Cluster's VINT size field.
  const szLen = vintLength(buf, pos);
  if (szLen === 0) return false;
  pos += szLen;

  // Walk elements inside the Cluster looking for a SimpleBlock (0xA3).
  while (pos < buf.length) {
    if (pos + 1 >= buf.length) break;
    const elemId = buf[pos++];

    const eSzLen = vintLength(buf, pos);
    if (eSzLen === 0) break;
    const elemSize = vintValue(buf, pos, eSzLen);
    pos += eSzLen;

    if (elemId === 0xA3) {
      // SimpleBlock: [TrackNumber VINT][Timecode 2B][Flags 1B][frame data]
      const tLen = vintLength(buf, pos);
      if (tLen === 0) break;
      const flagPos = pos + tLen + 2;
      if (flagPos >= buf.length) break;
      return (buf[flagPos] & 0x80) !== 0;  // bit 7 = keyframe
    }

    // Skip element body. elemSize === -1 means unknown size — stop walking.
    if (elemSize < 0 || pos + elemSize > buf.length) break;
    pos += elemSize;
  }
  return false;
}

function vintLength(buf, offset) {
  if (offset >= buf.length) return 0;
  const b = buf[offset];
  if (b & 0x80) return 1;
  if (b & 0x40) return 2;
  if (b & 0x20) return 3;
  if (b & 0x10) return 4;
  if (b & 0x08) return 5;
  if (b & 0x04) return 6;
  if (b & 0x02) return 7;
  if (b & 0x01) return 8;
  return 0;
}

function vintValue(buf, offset, len) {
  const widthBit = 0x80 >> (len - 1);
  let val = buf[offset] & (widthBit - 1);
  for (let i = 1; i < len; i++) val = (val * 256) + buf[offset + i];
  const allOnes = Math.pow(2, 7 * len) - 1;
  return val === allOnes ? -1 : val;
}

// ===========================================================================
// BROADCASTER
// ===========================================================================
let mediaRecorder  = null;
let broadcastStream = null;
let bChunkCount    = 0;

// Serialiseert chunk-uploads: elke fetch wacht op de vorige zodat chunks
// altijd in volgorde bij de server aankomen, ook bij async verwerking.
let uploadChain = Promise.resolve();

function selectMimeType() {
  const candidates = [
    'video/webm;codecs=vp8,opus',
    'video/webm;codecs=vp9,opus',
    'video/webm;codecs=vp8',
    'video/webm'
  ];
  for (const t of candidates) {
    if (MediaRecorder.isTypeSupported(t)) return t;
  }
  return '';
}

async function startBroadcast() {
  try {
    await fetch('/api/stream/reset', { method: 'POST' });

    broadcastStream = await navigator.mediaDevices.getUserMedia({
      video: { width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30 } },
      audio: true
    });
  } catch (err) {
    setStatus('b-status', 'Fout: ' + err.message, 'err');
    return;
  }

  document.getElementById('broadcaster-preview').srcObject = broadcastStream;

  const mimeType = selectMimeType();
  if (!mimeType) {
    setStatus('b-status', 'Geen ondersteunde video codec gevonden.', 'err');
    return;
  }

  bChunkCount    = 0;
  uploadChain    = Promise.resolve();
  let firstChunk = true;   // eerste chunk na reset = init segment
  document.getElementById('b-chunks').textContent = '0';

  mediaRecorder = new MediaRecorder(broadcastStream, {
    mimeType,
    videoBitsPerSecond: 1_500_000,
    audioBitsPerSecond: 128_000
  });

  mediaRecorder.ondataavailable = (event) => {
    if (!event.data || event.data.size === 0) return;

    bChunkCount++;
    document.getElementById('b-chunks').textContent = bChunkCount;

    // Capture the Blob immediately — before any await — so each chunk is
    // enqueued synchronously. The actual upload is chained onto uploadChain
    // so chunks always arrive at the server in order.
    const blob = event.data;

    const isInit = firstChunk;
    firstChunk = false;

    uploadChain = uploadChain.then(async () => {
      const buf = await blob.arrayBuffer();
      const isKeyframe = !isInit && webmHasKeyframe(new Uint8Array(buf));

      try {
        const res = await fetch('/api/stream/broadcast', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/octet-stream',
            'X-Mime-Type': mimeType,
            'X-Is-Init':     isInit     ? 'true' : 'false',
            'X-Is-Keyframe': isKeyframe ? 'true' : 'false'
          },
          body: buf
        });
        if (res.ok) {
          const json = await res.json();
          document.getElementById('b-viewers').textContent = json.viewers ?? 0;
          setStatus('b-status', `Actief — codec: ${mimeType}`, 'ok');
        } else {
          setStatus('b-status', `Server fout: ${res.status}`, 'err');
        }
      } catch (err) {
        setStatus('b-status', 'Netwerkfout: ' + err.message, 'err');
      }
    });
  };

  mediaRecorder.onerror = (err) => {
    setStatus('b-status', 'MediaRecorder fout: ' + err.error?.message, 'err');
  };

  mediaRecorder.start(250);

  document.getElementById('b-start').disabled = true;
  document.getElementById('b-stop').disabled = false;
  setStatus('b-status', 'Starten...', 'info');
}

function stopBroadcast() {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
  mediaRecorder = null;

  if (broadcastStream) {
    broadcastStream.getTracks().forEach(t => t.stop());
    broadcastStream = null;
  }

  document.getElementById('broadcaster-preview').srcObject = null;
  document.getElementById('b-start').disabled = false;
  document.getElementById('b-stop').disabled = true;
  setStatus('b-status', 'Gestopt');
}

// ===========================================================================
// VIEWER
// ===========================================================================
let eventSource   = null;
let mediaSource   = null;
let sourceBuffer  = null;
let pendingChunks = [];   // { data, isInit, isKeyframe }
let initDone      = false;
let isAppending   = false;
let vChunkCount   = 0;
let activeMime    = '';
let liveTimer     = null;

const MIME_CANDIDATES = [
  'video/webm;codecs=vp8,opus',
  'video/webm;codecs=vp9,opus',
  'video/webm;codecs=vp8',
  'video/webm'
];

const MAX_QUEUE = 20;

function base64ToUint8Array(b64) {
  const binary = atob(b64);
  const buf = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) buf[i] = binary.charCodeAt(i);
  return buf;
}

function evictOldBuffer() {
  if (!sourceBuffer || sourceBuffer.updating) return;
  if (!mediaSource || mediaSource.readyState !== 'open') return;
  try {
    const ct = document.getElementById('viewer-video').currentTime;
    if (ct > 20) sourceBuffer.remove(0, ct - 20);
  } catch (e) { /* ignore */ }
}

function syncToLive() {
  if (!sourceBuffer || !mediaSource || mediaSource.readyState !== 'open') return;
  if (sourceBuffer.updating) return;
  const video = document.getElementById('viewer-video');
  if (video.readyState < 2) return;
  try {
    const buffered = sourceBuffer.buffered;
    if (buffered.length === 0) return;
    const liveEdge = buffered.end(buffered.length - 1);
    if (liveEdge - video.currentTime > 1.5) video.currentTime = liveEdge - 0.1;
  } catch (e) { /* ignore */ }
}

function drainQueue() {
  if (isAppending) { console.log('[drain] skip: isAppending'); return; }
  if (!sourceBuffer || sourceBuffer.updating) { console.log('[drain] skip: sb.updating=', sourceBuffer?.updating); return; }
  if (!mediaSource || mediaSource.readyState !== 'open') { console.log('[drain] skip: ms.readyState=', mediaSource?.readyState); return; }
  if (pendingChunks.length === 0) return;

  const next = pendingChunks[0];
  if (!next.isInit && !initDone) { console.log('[drain] skip: waiting for init'); return; }

  isAppending = true;
  const item = pendingChunks.shift();
  console.log('[drain] appending isInit=', item.isInit, 'bytes=', item.data.byteLength, 'queueLeft=', pendingChunks.length);
  document.getElementById('v-queue').textContent = pendingChunks.length;

  function onUpdateEnd() {
    isAppending = false;
    if (item.isInit) {
      initDone = true;
      setStatus('v-status', 'Init verwerkt, stream start...', 'info');
    }
    drainQueue();
  }
  sourceBuffer.addEventListener('updateend', onUpdateEnd, { once: true });

  try {
    sourceBuffer.appendBuffer(item.data);
  } catch (err) {
    sourceBuffer.removeEventListener('updateend', onUpdateEnd);
    console.error('[drain] appendBuffer error:', err.name, err.message, 'isInit=', item.isInit);
    isAppending = false;
    if (err.name === 'QuotaExceededError') {
      evictOldBuffer();
      pendingChunks.unshift(item);
      setTimeout(drainQueue, 50);
    }
  }
}

function queueChunk(data, isInit = false) {
  if (isInit) {
    pendingChunks = [{ data, isInit: true }];
    initDone = false;
    drainQueue();
    return;
  }

  // Gewone media-chunk: wachten totdat init verwerkt is
  if (!initDone) return;

  pendingChunks.push({ data, isInit: false });
  while (pendingChunks.length > MAX_QUEUE) pendingChunks.shift();
  document.getElementById('v-queue').textContent = pendingChunks.length;
  drainQueue();
}

async function openSourceBuffer() {
  let serverMime = '';
  try {
    const res = await fetch('/api/stream/info');
    if (res.ok) serverMime = (await res.json()).mimeType || '';
  } catch (e) { /* val terug op kandidatenlijst */ }

  const candidates = serverMime
    ? [serverMime, ...MIME_CANDIDATES.filter(m => m !== serverMime)]
    : MIME_CANDIDATES;

  for (const mime of candidates) {
    if (!MediaSource.isTypeSupported(mime)) continue;
    try {
      sourceBuffer = mediaSource.addSourceBuffer(mime);
      sourceBuffer.mode = 'sequence';
      activeMime = mime;
      setStatus('v-status', `Verbonden (${mime}). Wachten op stream...`, 'info');
      connectEventSource();
      liveTimer = setInterval(syncToLive, 1000);
      return;
    } catch (e) { /* probeer volgende */ }
  }
  setStatus('v-status', 'Geen ondersteunde MSE codec beschikbaar.', 'err');
}

function startWatching() {
  pendingChunks = [];
  initDone      = false;
  isAppending   = false;
  vChunkCount   = 0;
  activeMime    = '';
  document.getElementById('v-chunks').textContent = '0';
  document.getElementById('v-queue').textContent  = '0';

  const video = document.getElementById('viewer-video');
  mediaSource = new MediaSource();
  video.src = URL.createObjectURL(mediaSource);

  mediaSource.addEventListener('sourceopen', openSourceBuffer);
  mediaSource.addEventListener('sourceended', () => {
    console.log('[ms] sourceended — readyState=', mediaSource.readyState);
    console.trace();
    setStatus('v-status', 'Stream beëindigd.', 'info');
  });
  mediaSource.addEventListener('sourceclose', () => {
    console.log('[ms] sourceclose — readyState=', mediaSource.readyState);
    setStatus('v-status', 'MediaSource gesloten.', 'info');
  });

  document.getElementById('v-start').disabled = true;
  document.getElementById('v-stop').disabled  = false;
  setStatus('v-status', 'Verbinden...', 'info');
}

function connectEventSource() {
  eventSource = new EventSource('/api/stream/watch');

  eventSource.onopen = () =>
    setStatus('v-status', 'Verbonden. Wachten op init-segment...', 'info');

  eventSource.addEventListener('init', (event) => {
    vChunkCount = 0;
    document.getElementById('v-chunks').textContent = '0';
    setStatus('v-status', 'Init ontvangen, verwerken...', 'info');
    queueChunk(base64ToUint8Array(event.data), true);
  });

  // keyframe en chunk zijn beide gewone media-chunks voor de viewer —
  // het onderscheid is alleen relevant voor de server-side catch-up logica.
  function onMediaChunk(event) {
    queueChunk(base64ToUint8Array(event.data), false, false);
    vChunkCount++;
    document.getElementById('v-chunks').textContent = vChunkCount;
    const video = document.getElementById('viewer-video');
    if (video.paused && video.readyState >= 3) video.play().catch(() => {});
    if (vChunkCount === 1) setStatus('v-status', 'Stream actief.', 'ok');
  }
  eventSource.addEventListener('keyframe', onMediaChunk);
  eventSource.addEventListener('chunk',    onMediaChunk);

  eventSource.onerror = () => {
    setStatus('v-status', 'Verbinding onderbroken, herverbinden...', 'err');
    initDone      = false;
    pendingChunks = [];
    isAppending   = false;
  };
}

function stopWatching() {
  if (liveTimer) { clearInterval(liveTimer); liveTimer = null; }
  if (eventSource) { eventSource.close(); eventSource = null; }

  pendingChunks = [];
  initDone      = false;
  isAppending   = false;

  function teardown() {
    try {
      if (mediaSource && mediaSource.readyState === 'open') mediaSource.endOfStream();
    } catch (e) { /* ignore */ }
    mediaSource  = null;
    sourceBuffer = null;
    const video = document.getElementById('viewer-video');
    video.removeAttribute('src');
    video.load();
  }

  if (sourceBuffer && sourceBuffer.updating) {
    sourceBuffer.addEventListener('updateend', teardown, { once: true });
  } else {
    teardown();
  }

  document.getElementById('v-start').disabled = false;
  document.getElementById('v-stop').disabled  = true;
  setStatus('v-status', 'Verbroken.');
}
</script>
</body>
</html>
